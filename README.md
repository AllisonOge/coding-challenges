# coding-challenges
A compilation of some of the coding challenges I have encountered in my software engineering career journey. The problem sets will be touched with as many approaches as possible, brute force, recursion and so on and in the following programming languages python, c++ and javascript. 

The problem statements are briefly stated in the respective files but the links to the source are also provided in those files as well as in the table below. For some of the test cases (e.g. google kickstart problems), the test sets need to be downloaded and placed in the correct path ([watch this](https://youtu.be/OCxxdLKWS1s)).

There will be links to detailed notes and helpful videos if it is needed to aid your understanding. Have fun just like I did!

# Summary of problems, solution details, problem category and difficulty level

|Problem|Difficulty level| Solution detail|
|---|---|---|
|[**Two Sum**](python\two_sum.py) is a classic array problem on LeetCode where we are challenged with determining the pair of integers in a given array such that they add up to a target.|Easy|Uses hash-map complement lookup logic, which teaches constant-time lookup patterns and linear-time problem solving. Real-world: fraud/risk rules and inventory pair matching|
|[**Check if a linked list is palindrome**](python\is_palindrome.py) is a commonly asked technical question. It involves determining whether a linked list forms a palindrome or not.|Medium|Uses slow/fast pointers plus in-place reversal logic, which teaches linked-list partitioning, comparison, and structural restoration. Real-world: memory-efficient sequence integrity checks|
|[**H index**](python\h_index.py) is a problem from Google Kickstart competition 2022. One is tasked with determining the h-index score for a stream of publications after each paper|Medium|Uses running-count and threshold-update logic, which teaches streaming computation and rank-based metric maintenance. Real-world: live analytics dashboards and metric tracking|
|[**Magic Square**](python\magic_square.py) is a problem from HackerRank. One is tasked with determining the minimum cost magic square possible given a square matrix|Medium|Uses candidate-enumeration and cost-minimization logic, which teaches controlled brute force and objective-function comparison. Real-world: small-state optimization and puzzle engines|
|[**Pascal Triangle**](python\pascal_triangle.py) is a challenge where we build the first n rows of the Pascal triangle. In this challenge we learn nested iteration, combinatorial patters and clean list construction |Easy|Uses row-by-row neighbor-sum construction logic, which teaches nested iteration, combinatorial patterns, and clean list building. Real-world: probability distributions and binomial expansion|
|[**Lock Boxes**](python\lockboxes.py) is a challenge where we are given boxes with keys, to determine if all boxes can be opened. We learn graph reachability (DFS/BFS mindset), set usage and traversal logic |Easy|Uses depth first search reachability logic over boxes-as-nodes, which teaches traversal strategy, visited-state tracking, and graph thinking. Real-world: permission/path reachability in systems and networks|
|[**Minimum Operation**](python\minimum_operations.py) is a challenge of finding the minimum copy/paste operations to reach n characters. We learn fatorization-based optimization, dynamic thinking, and greedy vs brute force tradeoffs |Medium|Uses prime-factor decomposition logic, which teaches how multiplicative structure leads to optimal operation counts. Real-world: operation planning and cost minimization workflows|
|[**Log Parsing**](python\log_parsing.py) is a challenge where we parse streaming log lines, track totals and print periodic stats robustly. We learn input validation, stateful stream processing, and defensive coding. |Medium|Uses regex-validated stream aggregation logic, which teaches robust parsing, stateful counting, and defensive input handling. Real-world: observability pipelines and incident monitoring|
|[**UTF8 Validation**](python\utf8_validation.py) is a challenge that checks whether byte sequences follow UTF-8 encoding rules. We learn bitwise operations, binary protocol reasoning, and strict edge-case handling |Medium|Uses bit-prefix and continuation-byte validation logic, which teaches bitwise protocol checks and strict state transitions. Real-world: API gateways and file ingestion validation|
|[**N Queens**](python\nqueens.py) is a challenge that places N queens so none attacks another and prints all valid boards. We learn backtracking, constraint pruning, recursion, and search-space control. |Hard|Uses recursive backtracking with diagonal/column constraints, which teaches pruning, recursion depth control, and search efficiency. Real-world: scheduling and constraint-satisfaction solvers|
|[**StarWars Characters API**](python\starwars_characters.py) is a challenge where we fetch and print movie character names in order from an API. We learn asychronous API calls, request sequencing, and Node.js I/O flow. |Easy|Uses ordered API fetch-and-map logic, which teaches request sequencing, data dependency flow, and testable I/O boundaries. Real-world: orchestrating dependent microservice/API calls|
|[**Rotate 2D Matrix**](python\rotate_2d_matrix.py) is a challenge of rotatiing an `n x n` matrix 90 degrees clockwise in place. We learn in-place transformations, index mapping, and space/time efficiency. |Medium|Uses layer-by-layer 4-way swap logic, which teaches index mapping and in-place transformation with O(1) extra space. Real-world: image/grid transforms in graphics and games|
|[**Making Change**](python\making_change.py) challenge retursn minimum number of coins needed for a target amount. We learn greedy strategy boundaries, coin-system assumptions, and algorithm correctness reasoning. |Medium|Uses bottom-up dynamic programming logic, which teaches optimal substructure and why DP outperforms naive greedy choices. Real-world: pricing engines and resource allocation|
|[**Island Perimeter**](python\island_perimeter.py) challenge computes island perimeter from a grid map. We learn grid traversal, neighbour checks, and translating geometry into counting logic. |Easy|Uses edge-count with shared-side subtraction logic, which teaches grid scanning and geometric counting conversion. Real-world: map/voxel boundary calculations|
|[**Prime Game**](python\prime_game.py) is a challenge where we determine the winner of rouns where players remove prime-related values up to n. We learn sieve/precomputaiton, prefix counting, and game-theory-style winner analysis. |Medium|Uses sieve precomputation plus parity-of-prime-count logic, which teaches fast repeated queries and game outcome reasoning. Real-world: repeated-query optimization in analytics|

